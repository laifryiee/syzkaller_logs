// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>

#ifndef __NR_close_range
#define __NR_close_range 436
#endif

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i = 0;
  for (; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

static void setup_sysctl()
{
  char mypid[32];
  snprintf(mypid, sizeof(mypid), "%d", getpid());
  struct {
    const char* name;
    const char* data;
  } files[] = {
      {"/sys/kernel/debug/x86/nmi_longest_ns", "10000000000"},
      {"/proc/sys/kernel/hung_task_check_interval_secs", "20"},
      {"/proc/sys/net/core/bpf_jit_kallsyms", "1"},
      {"/proc/sys/net/core/bpf_jit_harden", "0"},
      {"/proc/sys/kernel/kptr_restrict", "0"},
      {"/proc/sys/kernel/softlockup_all_cpu_backtrace", "1"},
      {"/proc/sys/fs/mount-max", "100"},
      {"/proc/sys/vm/oom_dump_tasks", "0"},
      {"/proc/sys/debug/exception-trace", "0"},
      {"/proc/sys/kernel/printk", "7 4 1 3"},
      {"/proc/sys/kernel/keys/gc_delay", "1"},
      {"/proc/sys/vm/oom_kill_allocating_task", "1"},
      {"/proc/sys/kernel/ctrl-alt-del", "0"},
      {"/proc/sys/kernel/cad_pid", mypid},
  };
  for (size_t i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
    if (!write_file(files[i].name, files[i].data))
      printf("write to %s failed: %s\n", files[i].name, strerror(errno));
  }
}

#define USLEEP_FORKED_CHILD (3 * 50 * 1000)

static long handle_clone_ret(long ret)
{
  if (ret != 0) {
    return ret;
  }
  usleep(USLEEP_FORKED_CHILD);
  syscall(__NR_exit, 0);
  while (1) {
  }
}

static long syz_clone(volatile long flags, volatile long stack,
                      volatile long stack_len, volatile long ptid,
                      volatile long ctid, volatile long tls)
{
  long sp = (stack + stack_len) & ~15;
  long ret = (long)syscall(__NR_clone, flags & ~CLONE_VM, sp, ptid, ctid, tls);
  return handle_clone_ret(ret);
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  for (call = 0; call < 27; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (call == 2 || call == 5 || call == 9 || call == 12 || call == 13 ||
          call == 14 || call == 15 || call == 19 || call == 20 || call == 23)
        break;
      event_timedwait(&th->done, 50);
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[13] = {0x0,
                  0x0,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res = 0;
  switch (call) {
  case 0:
    res = syscall(__NR_ioctl, /*fd=*/-1, /*cmd=*/0xc0502100,
                  /*arg=*/0x20000f00ul);
    if (res != -1)
      r[0] = *(uint32_t*)0x20000f08;
    break;
  case 1:
    res = -1;
    res = syz_clone(/*flags=*/0, /*stack=*/0, /*stack_len=*/0, /*parentid=*/0,
                    /*childtid=*/0, /*tls=*/0);
    if (res != -1)
      r[1] = res;
    break;
  case 2:
    syscall(__NR_ioprio_set, /*which=*/2ul, /*who=*/r[1], /*ioprio=*/0ul);
    break;
  case 3:
    memcpy((void*)0x20000080, "./file0\000", 8);
    res = syscall(__NR_openat, /*fd=*/0xffffff9c, /*file=*/0x20000080ul,
                  /*flags=*/0x105042ul, /*mode=*/0ul);
    if (res != -1)
      r[2] = res;
    break;
  case 4:
    *(uint64_t*)0x20000fc0 = 0x200005c0;
    *(uint16_t*)0x200005c0 = 1;
    memcpy(
        (void*)0x200005c2,
        "./"
        "file0\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
        108);
    *(uint32_t*)0x20000fc8 = 0x6e;
    *(uint64_t*)0x20000fd0 = 0;
    *(uint64_t*)0x20000fd8 = 0;
    *(uint64_t*)0x20000fe0 = 0x200009c0;
    memcpy((void*)0x200009c0,
           "\x20\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00",
           16);
    *(uint32_t*)0x200009d0 = -1;
    *(uint32_t*)0x200009d4 = -1;
    *(uint32_t*)0x200009d8 = -1;
    *(uint32_t*)0x200009dc = -1;
    memcpy((void*)0x200009e0,
           "\x28\x00\x00\x00\x00\x00\x00\x00\x01\x05\x00\x00\x01\x00\x00\x00",
           16);
    *(uint32_t*)0x200009f0 = -1;
    *(uint32_t*)0x200009f4 = -1;
    *(uint32_t*)0x200009f8 = -1;
    *(uint32_t*)0x200009fc = -1;
    *(uint32_t*)0x20000a00 = -1;
    *(uint32_t*)0x20000a04 = -1;
    memcpy((void*)0x20000a08,
           "\x2c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00",
           16);
    *(uint32_t*)0x20000a18 = -1;
    *(uint32_t*)0x20000a1c = -1;
    *(uint32_t*)0x20000a20 = -1;
    *(uint32_t*)0x20000a24 = -1;
    *(uint32_t*)0x20000a28 = -1;
    *(uint32_t*)0x20000a2c = -1;
    *(uint32_t*)0x20000a30 = -1;
    memcpy((void*)0x20000a34,
           "\x00\x00\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00"
           "\x01\x00\x00\x00",
           20);
    *(uint8_t*)0x20000a48 = r[2];
    *(uint32_t*)0x20000a49 = -1;
    memcpy((void*)0x20000a4d,
           "\x14\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00",
           16);
    *(uint32_t*)0x20000a5d = -1;
    memcpy((void*)0x20000a61,
           "\x00\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00"
           "\x02\x00\x00\x00",
           20);
    *(uint32_t*)0x20000a75 = 0;
    *(uint32_t*)0x20000a79 = 0;
    *(uint32_t*)0x20000a7d = 0;
    memcpy((void*)0x20000a81,
           "\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00"
           "\x01\x00\x00\x00",
           20);
    *(uint32_t*)0x20000a95 = -1;
    *(uint32_t*)0x20000a99 = -1;
    *(uint32_t*)0x20000a9d = -1;
    *(uint32_t*)0x20000aa1 = -1;
    memcpy((void*)0x20000aa5,
           "\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00",
           16);
    *(uint32_t*)0x20000ab5 = 0;
    *(uint32_t*)0x20000ab9 = 0;
    *(uint32_t*)0x20000abd = 0;
    memcpy((void*)0x20000ac1,
           "\x00\x00\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00"
           "\x01\x00\x00\x00",
           20);
    *(uint32_t*)0x20000ad5 = -1;
    memset((void*)0x20000ad9, 0, 4);
    *(uint64_t*)0x20000fe8 = 0x120;
    *(uint32_t*)0x20000ff0 = 0x48080;
    *(uint32_t*)0x20000ff8 = 0;
    *(uint64_t*)0x20001000 = 0;
    *(uint32_t*)0x20001008 = 0;
    *(uint64_t*)0x20001010 = 0x20000e80;
    *(uint64_t*)0x20000e80 = 0x20000b00;
    memcpy(
        (void*)0x20000b00,
        "\x14\x26\xf6\x41\xc6\x73\x98\xe6\xfe\x94\x4f\xbd\x37\xe5\xf7\x18\x1a"
        "\x51\xff\x3f\xf9\x86\x21\xb2\x40\x49\x34\x46\xa9\x50\x89\x08\xac\x25"
        "\x99\xd3\xb2\x59\x1a\xdb\x93\x87\x94\xbe\xf5\x88\x80\x9e\xdf\xcf\x7b"
        "\x5e\x22\xa3\x14\xaf\x25\x51\x8d\x87\x9f\x32\x2e\x1e\x03\x16\x1e\xb5"
        "\xfe\x2e\xc7\x25\xfa\x09\xaf\xed\xac\x63\x79\x55\x3d\x25",
        82);
    *(uint64_t*)0x20000e88 = 0x52;
    *(uint64_t*)0x20000e90 = 0x20000b80;
    memcpy(
        (void*)0x20000b80,
        "\x6c\x24\x58\x62\xf0\x84\x99\x3e\x00\xd7\x7b\x47\x2f\xd4\x72\xec\x3e"
        "\x0b\x3e\x10\xbc\x17\xa1\xb0\x10\x71\x79\xca\xea\x08\xbb\x34\x3b\x16"
        "\xbf\xe8\xab\x1e\x0f\xf3\x44\x31\xe3\x95\x7c\x02\x2c\xe2\x38\x4a\x03"
        "\xc3\xbc\x0a\x98\xa2\x8a\xf1\x84\x84\xbe\x28\x9a\xb2\x7b\x5a\x10\x45"
        "\x89\x64\xc3\x21\x74\x82\xab\xee\xa4\x65\x8a\xef\x97\x95\x55\x63\x4d"
        "\xe7\x08\x19\x9c\x06\x90\x83\x1b\x04\x9f\xd2\xcd\x09\xd6\x96\xf1\x08"
        "\x3b\x1a\x2a\x14\x53\x44\x50\x0c\xe0\x06\x8c\x00\xea\xb1\xec\x44\x57"
        "\x9d\x61\x19\xf0\x13\x37\x44\x99\xa7\x76\xc4\xff\xe4\x40\x43\x82\x91"
        "\x71\xda\x4d\x99\xf0\x10\x9a\x86\xa8\x56\x4b\x1e\x9a\xcf\x34\x6d\x2b"
        "\x2d\xff\xd5\x91\xff\xa3\xf0\xe4\xdd\x8d\x3c\xf9\x66\x72\x19\x6c\x86"
        "\x05\xc5\xe9\xaa\x74\x2c\xd8\x65\x37\x3b\x35\xeb\x2e\x77\x98\x78\xd1"
        "\xa5\x49\x94\xc8\xea\xf2",
        193);
    *(uint64_t*)0x20000e98 = 0xc1;
    *(uint64_t*)0x20000ea0 = 0x20000c80;
    memcpy((void*)0x20000c80,
           "\x72\x1c\x1f\x63\x7c\xe6\x33\x0f\xd5\xc2\x92\x5e\x30\x82\xe0\xe2"
           "\x51\x95\x2c\xc8\xef\xef\x35\x23\xe3\x51\xa4\xcc\x83\x28\x3b\xf1"
           "\xb2\xda\x33\x51\x07\xcb\xa6\xaf\x2a\xb1\xa0\x24\x1c\x2a\xc0\xf2"
           "\x5a\x8d\x82\xa4\x29\x0a\x39\x7d\x0b\x47\xfe\xfc\x32\x5e\xb5\x02"
           "\x94\xff\xfa\x21\xfb\x2a\x95\x76\x07\x84\xe8",
           75);
    *(uint64_t*)0x20000ea8 = 0x4b;
    *(uint64_t*)0x20000eb0 = 0x20000d00;
    *(uint64_t*)0x20000eb8 = 0;
    *(uint64_t*)0x20000ec0 = 0x20000d40;
    memcpy(
        (void*)0x20000d40,
        "\x7b\xe8\xd3\x77\xaf\x27\x06\xa9\x8f\x10\xe0\x7a\xc2\x6b\xf9\xa9\x77"
        "\x08\x05\x95\x26\xbb\xa1\x05\x07\x77\x19\x5a\xd9\x4e\xf5\xf9\x9c\xc8"
        "\x94\x30\xff\xe5\x33\x97\x1c\x19\xf6\x51\x97\x62\x78\xb6\xa4\x6e\xd7"
        "\x23\xde\xd8\xc6\x7d\xbd\x98\x3f\x0e\xbe\x30\x78\xfd\x40\x61\x96",
        67);
    *(uint64_t*)0x20000ec8 = 0x43;
    *(uint64_t*)0x20000ed0 = 0x20000dc0;
    memcpy(
        (void*)0x20000dc0,
        "\xc8\xee\x64\x85\x92\xf1\xb0\x49\x99\x7f\xfd\x48\x98\x76\xa4\x76\x68"
        "\xfd\x5e\xb1\x9e\xc8\xab\xb1\xb7\xd0\x67\xc0\x87\xfc\xaa\x01\x19\x91"
        "\xe3\x20\x2e\xa9\x73\x35\xdb\x81\x4b\x04\x73\xb1\xd7\x98\x59\x98\x32"
        "\xeb\xa0\x3f\x93\xb3\xd9\xee\x14\xc8\xa2\xd1\xc1\x1e\x1e\xca\x96\x73"
        "\x2c\x87\x37\x4b\xc0\x64\x34\x90\xa7\x9d\x58\xdd\xc4\x1f\x5f\x94\xfc"
        "\xe3\x9b\xd0\x84\x87\x16\x9c\xb8\x55\xb2\x0d\x11\x10\xa1\xa7\xdd\x2a"
        "\xc3\x86\x49\x94\x93\x23\xe8\xab\xcf\x0a\xe2\xe8\x6b\xd2\xd2\x55\x7b"
        "\x1f\x60\x73\x4d\x0d\x71\x94\x19\x5c\x4a\x52\x51\x37\xdf\x19\x13\x44"
        "\xe6\x76\x47\x7e\x6e\xc7\xfc\x78\x7f\x89\x77\x20\xb9\x9f\x98\x14\xf1"
        "\x61\xc6\xe4\xf1\x2f\x73\xd1\xf8\xde\x71\xfb\x25\x9d\x29\xcc\xf1\xd1"
        "\x24\x07\xc5\x52\xf6\x8b\x0a\xb5\x4f\x3c\x95\xe4\xee",
        183);
    *(uint64_t*)0x20000ed8 = 0xb7;
    *(uint64_t*)0x20001018 = 6;
    *(uint64_t*)0x20001020 = 0x20000f80;
    *(uint64_t*)0x20000f80 = 0x1c;
    *(uint32_t*)0x20000f88 = 1;
    *(uint32_t*)0x20000f8c = 2;
    *(uint32_t*)0x20000f90 = r[0];
    *(uint32_t*)0x20000f94 = 0xee00;
    *(uint32_t*)0x20000f98 = 0xee01;
    *(uint64_t*)0x20000fa0 = 0x1c;
    *(uint32_t*)0x20000fa8 = 1;
    *(uint32_t*)0x20000fac = 2;
    *(uint32_t*)0x20000fb0 = r[1];
    *(uint32_t*)0x20000fb4 = -1;
    *(uint32_t*)0x20000fb8 = 0;
    *(uint64_t*)0x20001028 = 0x40;
    *(uint32_t*)0x20001030 = 0x40834;
    *(uint32_t*)0x20001038 = 0;
    syscall(__NR_sendmmsg, /*fd=*/-1, /*mmsg=*/0x20000fc0ul, /*vlen=*/2ul,
            /*f=*/0x40000ul);
    break;
  case 5:
    syz_clone(/*flags=*/0x40000200, /*stack=*/0, /*stack_len=*/0,
              /*parentid=*/0x20000640, /*childtid=*/0, /*tls=*/0);
    break;
  case 6:
    syscall(__NR_getsockopt, /*fd=*/-1, /*level=*/6, /*optname=*/0,
            /*optval=*/0ul, /*optlen=*/0ul);
    break;
  case 7:
    res = syscall(__NR_socket, /*domain=*/2ul, /*type=*/1ul, /*proto=*/0);
    if (res != -1)
      r[3] = res;
    break;
  case 8:
    syscall(__NR_close_range, /*fd=*/r[3], /*max_fd=*/r[3], /*flags=*/0ul);
    break;
  case 9:
    syscall(__NR_io_setup, /*n=*/2, /*ctx=*/0x20000000ul);
    break;
  case 10:
    *(uint32_t*)0x200000c0 = 1;
    *(uint32_t*)0x200000c4 = 0x80;
    *(uint8_t*)0x200000c8 = 0;
    *(uint8_t*)0x200000c9 = 0;
    *(uint8_t*)0x200000ca = 0;
    *(uint8_t*)0x200000cb = 0;
    *(uint32_t*)0x200000cc = 0;
    *(uint64_t*)0x200000d0 = 0;
    *(uint64_t*)0x200000d8 = 0;
    *(uint64_t*)0x200000e0 = 0;
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 0, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 1, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 2, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 3, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 4, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 5, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 6, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 7, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 8, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 9, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 10, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 11, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 12, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 13, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 14, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 15, 2);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 1, 17, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 18, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 19, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 20, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 21, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 22, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 23, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 24, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 25, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 26, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 27, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 28, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 29, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 30, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 31, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 32, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 33, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 34, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 35, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 36, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 37, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 38, 26);
    *(uint32_t*)0x200000f0 = 0;
    *(uint32_t*)0x200000f4 = 0;
    *(uint64_t*)0x200000f8 = 0;
    *(uint64_t*)0x20000100 = 0;
    *(uint64_t*)0x20000108 = 0;
    *(uint64_t*)0x20000110 = 0;
    *(uint32_t*)0x20000118 = 0;
    *(uint32_t*)0x2000011c = 0;
    *(uint64_t*)0x20000120 = 0;
    *(uint32_t*)0x20000128 = 0;
    *(uint16_t*)0x2000012c = 0;
    *(uint16_t*)0x2000012e = 0;
    *(uint32_t*)0x20000130 = 0;
    *(uint32_t*)0x20000134 = 0;
    *(uint64_t*)0x20000138 = 0;
    res = syscall(__NR_perf_event_open, /*attr=*/0x200000c0ul, /*pid=*/0,
                  /*cpu=*/-1, /*group=*/-1, /*flags=*/0ul);
    if (res != -1)
      r[4] = res;
    break;
  case 11:
    memcpy((void*)0x20000080, "./file0\000", 8);
    res = syscall(__NR_openat, /*fd=*/0xffffff9c, /*file=*/0x20000080ul,
                  /*flags=*/0x105042ul, /*mode=*/0ul);
    if (res != -1)
      r[5] = res;
    break;
  case 12:
    syscall(__NR_write, /*fd=*/r[5], /*arg=*/0x20000000ul,
            /*len=*/0xfffffdeful);
    break;
  case 13:
    *(uint32_t*)0x20000480 = 1;
    *(uint16_t*)0x20000488 = 2;
    *(uint16_t*)0x2000048a = htobe16(0x4e23);
    *(uint8_t*)0x2000048c = 0xac;
    *(uint8_t*)0x2000048d = 0x14;
    *(uint8_t*)0x2000048e = 0x14;
    *(uint8_t*)0x2000048f = 0xbb;
    *(uint16_t*)0x20000508 = 2;
    *(uint16_t*)0x2000050a = htobe16(0x4e23);
    *(uint8_t*)0x2000050c = 0xac;
    *(uint8_t*)0x2000050d = 0x14;
    *(uint8_t*)0x2000050e = 0x14;
    *(uint8_t*)0x2000050f = 0xaa;
    syscall(__NR_setsockopt, /*fd=*/r[5], /*level=*/0, /*optname=*/0x28,
            /*optval=*/0x20000480ul, /*optlen=*/0x108ul);
    {
      int i;
      for (i = 0; i < 32; i++) {
        syscall(__NR_setsockopt, /*fd=*/r[5], /*level=*/0, /*optname=*/0x28,
                /*optval=*/0x20000480ul, /*optlen=*/0x108ul);
      }
    }
    break;
  case 14:
    syscall(__NR_mmap, /*addr=*/0x20ffc000ul, /*len=*/0x3000ul, /*prot=*/0ul,
            /*flags=*/0x13ul, /*fd=*/r[4], /*offset=*/0ul);
    {
      int i;
      for (i = 0; i < 32; i++) {
        syscall(__NR_mmap, /*addr=*/0x20ffc000ul, /*len=*/0x3000ul,
                /*prot=*/0ul, /*flags=*/0x13ul, /*fd=*/r[4], /*offset=*/0ul);
      }
    }
    break;
  case 15:
    *(uint32_t*)0x200000c0 = 1;
    *(uint32_t*)0x200000c4 = 0x80;
    *(uint8_t*)0x200000c8 = 0;
    *(uint8_t*)0x200000c9 = 0;
    *(uint8_t*)0x200000ca = 0;
    *(uint8_t*)0x200000cb = 0;
    *(uint32_t*)0x200000cc = 0;
    *(uint64_t*)0x200000d0 = 0;
    *(uint64_t*)0x200000d8 = 0;
    *(uint64_t*)0x200000e0 = 0;
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 0, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 1, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 2, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 3, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 4, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 5, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 6, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 7, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 8, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 9, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 10, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 11, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 12, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 13, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 14, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 15, 2);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 1, 17, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 18, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 19, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 20, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 21, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 22, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 23, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 24, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 25, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 26, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 27, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 28, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 29, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 30, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 31, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 32, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 33, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 34, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 35, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 36, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 37, 1);
    STORE_BY_BITMASK(uint64_t, , 0x200000e8, 0, 38, 26);
    *(uint32_t*)0x200000f0 = 0;
    *(uint32_t*)0x200000f4 = 0;
    *(uint64_t*)0x200000f8 = 0;
    *(uint64_t*)0x20000100 = 0;
    *(uint64_t*)0x20000108 = 0;
    *(uint64_t*)0x20000110 = 0;
    *(uint32_t*)0x20000118 = 0;
    *(uint32_t*)0x2000011c = 0;
    *(uint64_t*)0x20000120 = 0;
    *(uint32_t*)0x20000128 = 0;
    *(uint16_t*)0x2000012c = 0;
    *(uint16_t*)0x2000012e = 0;
    *(uint32_t*)0x20000130 = 0;
    *(uint32_t*)0x20000134 = 0;
    *(uint64_t*)0x20000138 = 0;
    res = syscall(__NR_perf_event_open, /*attr=*/0x200000c0ul, /*pid=*/0,
                  /*cpu=*/-1, /*group=*/-1, /*flags=*/0ul);
    {
      int i;
      for (i = 0; i < 32; i++) {
        syscall(__NR_perf_event_open, /*attr=*/0x200000c0ul, /*pid=*/0,
                /*cpu=*/-1, /*group=*/-1, /*flags=*/0ul);
      }
    }
    if (res != -1)
      r[6] = res;
    break;
  case 16:
    res =
        syscall(__NR_socket, /*domain=*/0x11ul, /*type=*/2ul, /*proto=*/0x300);
    if (res != -1)
      r[7] = res;
    break;
  case 17:
    res = syscall(__NR_dup2, /*oldfd=*/r[7], /*newfd=*/r[7]);
    if (res != -1)
      r[8] = res;
    break;
  case 18:
    *(uint16_t*)0x200000c0 = 0;
    *(uint16_t*)0x200000c2 = 0x8000;
    syscall(__NR_setsockopt, /*fd=*/r[8], /*level=*/0x107, /*optname=*/0x12,
            /*optval=*/0x200000c0ul, /*optlen=*/4ul);
    break;
  case 19:
    *(uint32_t*)0x20000400 = 2;
    *(uint32_t*)0x20000404 = 3;
    *(uint32_t*)0x20000408 = 8;
    *(uint32_t*)0x2000040c = 0;
    *(uint32_t*)0x20000410 = 2;
    *(uint32_t*)0x20000414 = 0x520;
    *(uint32_t*)0x20000418 = 3;
    *(uint16_t*)0x2000041c = 0x7ff;
    *(uint16_t*)0x2000041e = 0x401;
    *(uint32_t*)0x20000420 = 4;
    *(uint32_t*)0x20000424 = 0;
    *(uint32_t*)0x20000428 = 8;
    *(uint32_t*)0x2000042c = 0;
    syscall(__NR_setsockopt, /*fd=*/r[8], /*level=*/6, /*optname=*/0x16,
            /*optval=*/0x20000400ul, /*optlen=*/6ul);
    {
      int i;
      for (i = 0; i < 32; i++) {
        syscall(__NR_setsockopt, /*fd=*/r[8], /*level=*/6, /*optname=*/0x16,
                /*optval=*/0x20000400ul, /*optlen=*/6ul);
      }
    }
    break;
  case 20:
    syscall(__NR_mmap, /*addr=*/0x20ffc000ul, /*len=*/0x3000ul, /*prot=*/0ul,
            /*flags=*/0x13ul, /*fd=*/r[6], /*offset=*/0ul);
    {
      int i;
      for (i = 0; i < 32; i++) {
        syscall(__NR_mmap, /*addr=*/0x20ffc000ul, /*len=*/0x3000ul,
                /*prot=*/0ul, /*flags=*/0x13ul, /*fd=*/r[6], /*offset=*/0ul);
      }
    }
    break;
  case 21:
    res =
        syscall(__NR_socket, /*domain=*/0x11ul, /*type=*/2ul, /*proto=*/0x300);
    if (res != -1)
      r[9] = res;
    break;
  case 22:
    res = syscall(__NR_dup2, /*oldfd=*/r[9], /*newfd=*/r[9]);
    if (res != -1)
      r[10] = res;
    break;
  case 23:
    *(uint16_t*)0x200000c0 = 0;
    *(uint16_t*)0x200000c2 = 0x8000;
    syscall(__NR_setsockopt, /*fd=*/r[10], /*level=*/0x107, /*optname=*/0x12,
            /*optval=*/0x200000c0ul, /*optlen=*/4ul);
    break;
  case 24:
    res =
        syscall(__NR_socket, /*domain=*/0x11ul, /*type=*/2ul, /*proto=*/0x300);
    if (res != -1)
      r[11] = res;
    break;
  case 25:
    res = syscall(__NR_dup2, /*oldfd=*/r[11], /*newfd=*/r[11]);
    if (res != -1)
      r[12] = res;
    break;
  case 26:
    *(uint16_t*)0x200000c0 = 0;
    *(uint16_t*)0x200000c2 = 0x8000;
    syscall(__NR_setsockopt, /*fd=*/r[12], /*level=*/0x107, /*optname=*/0x12,
            /*optval=*/0x200000c0ul, /*optlen=*/4ul);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x20000000ul, /*len=*/0x1000000ul, /*prot=*/7ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x21000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  setup_sysctl();
  loop();
  return 0;
}
